import{_ as t,c as a,a2 as s,o as n}from"./chunks/framework.BkvI1e0W.js";const o="/PyOrchestrateDocumentation/assets/types_l.BJborE4P.svg",i="/PyOrchestrateDocumentation/assets/types_d.D3uaH4AE.svg",r="/PyOrchestrateDocumentation/assets/lifecycle_l.CYSvG69a.svg",l="/PyOrchestrateDocumentation/assets/lifecycle_d.DO6iXmEa.svg",c="/PyOrchestrateDocumentation/assets/events_l.R6tRAIsE.svg",d="/PyOrchestrateDocumentation/assets/events_d.DMrCploG.svg",v=JSON.parse('{"title":"How Agents Works","description":"","frontmatter":{"title":"How Agents Works","editLink":true},"headers":[],"relativePath":"learn/introduction/agents/index.md","filePath":"learn/introduction/agents/index.md","lastUpdated":1761471006000}'),h={name:"learn/introduction/agents/index.md"};function g(p,e,u,f,m,b){return n(),a("div",null,e[0]||(e[0]=[s('<h1 id="how-agents-works" tabindex="-1">How Agents Works <a class="header-anchor" href="#how-agents-works" aria-label="Permalink to &quot;How Agents Works&quot;">​</a></h1><p><strong>Agents</strong> are the core execution units managed by the Orchestrator.</p><p>Each Agent encapsulates a specific task and can run either in a separate <strong>thread</strong> or <strong>process</strong>. The Agent class provides a standardized lifecycle and configuration system, allowing you to focus solely on your business logic.</p><h2 id="getting-started" tabindex="-1">Getting Started <a class="header-anchor" href="#getting-started" aria-label="Permalink to &quot;Getting Started&quot;">​</a></h2><h3 id="agent-types" tabindex="-1">Agent Types <a class="header-anchor" href="#agent-types" aria-label="Permalink to &quot;Agent Types&quot;">​</a></h3><p><img src="'+o+'" alt="alt text" class="light-only" loading="lazy"><img src="'+i+'" alt="alt text" class="dark-only" loading="lazy"></p><p>Agents can be implemented in different styles, depending on their intended behavior:</p><ul><li><strong>OneShotAgent</strong>: performs a single task and then exits.</li><li><strong>LoopingAgent</strong>: continuously performs a task until externally stopped.</li><li><strong>PeriodicAgent</strong>: executes at regular time intervals.</li><li><strong>EventAgent</strong>: responds to external events or signals.</li><li><strong>ScheduledAgent</strong>: runs based on a predefined schedule.</li></ul><p>Each one builds on top of the core logic provided by <code>BaseAgent</code>, inheriting its lifecycle and configuration support.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>To learn more about the different Agent types, check out the <a href="./../../agents/#hierarchical-structure">Hierarchical Structure</a> section.</p></div><h3 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h3><p>Each Agent has a <code>Config</code> class that defines its settings, like how often it runs or where it saves output. You can override these defaults or extend the class for custom options, making Agents flexible and safe to use.</p><p>Built-in Agents use their configuration class to manage essential parameters. For example, the <code>LoopingAgent</code> defines options like loop interval and stop conditions in its config.</p><div class="tip custom-block"><p class="custom-block-title">Example</p><p>See the <a href="./../../../learn/agents/built-in-agents/loopingagent.html#configuration">LoopingAgent Config</a> for more details.</p></div><h3 id="plugin-system" tabindex="-1">Plugin System <a class="header-anchor" href="#plugin-system" aria-label="Permalink to &quot;Plugin System&quot;">​</a></h3><p>Agents support plugins to extend their capabilities. Plugins are automatically initialized and finalized with the Agent, and can be used to modularize logic or add monitoring, transformation, or communication features.</p><h3 id="thread-vs-process" tabindex="-1">Thread vs Process <a class="header-anchor" href="#thread-vs-process" aria-label="Permalink to &quot;Thread vs Process&quot;">​</a></h3><p>Agents can run as:</p><ul><li><strong>Thread-based</strong>: share memory, lightweight, best for I/O-bound tasks.</li><li><strong>Process-based</strong>: isolated, resilient, ideal for CPU-intensive or crash-prone tasks.</li></ul><p>This is defined at the time of Agent creation and is managed internally by the Orchestrator.</p><h2 id="lifecycle" tabindex="-1">Lifecycle <a class="header-anchor" href="#lifecycle" aria-label="Permalink to &quot;Lifecycle&quot;">​</a></h2><p><img src="'+r+'" alt="alt text" class="light-only" loading="lazy"><img src="'+l+'" alt="alt text" class="dark-only" loading="lazy"></p><p>All Agents follow a standardized lifecycle:</p><ol><li><p><strong>Config Validation</strong><br> The Agent checks its configuration for correctness. If any issues are found, the Agent will not start.</p></li><li><p><strong>Setup</strong><br> Executed before the task starts. Use this step for initialization and preparation.</p></li><li><p><strong>Execution</strong><br> The core of the Agent. This is where the main task is performed — once, repeatedly, or on trigger.</p></li><li><p><strong>Stop</strong><br> When the Orchestrator requests a stop or the Agent finishes its tasks.</p></li></ol><p>Throughout this lifecycle, internal and external events are used to synchronize actions and manage state transitions.</p><h2 id="observability-and-events" tabindex="-1">Observability and Events <a class="header-anchor" href="#observability-and-events" aria-label="Permalink to &quot;Observability and Events&quot;">​</a></h2><p>Each Agent manages two kinds of event systems.</p><p><img src="'+c+'" alt="alt text" class="light-only" loading="lazy"><img src="'+d+'" alt="alt text" class="dark-only" loading="lazy"></p><h3 id="messagechannel" tabindex="-1">MessageChannel <a class="header-anchor" href="#messagechannel" aria-label="Permalink to &quot;MessageChannel&quot;">​</a></h3><p>Agents do not emit events directly. Instead, when an agent needs to signal an event (such as a state change or a lifecycle transition), it sends a message through a <strong>MessageChannel</strong> to the Orchestrator. The Orchestrator then receives this message and emits the corresponding event using its EventManager. This architecture ensures a clear separation between agent logic and event handling, and allows for centralized monitoring and control.</p><p><strong>Event flow:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Agent → MessageChannel → Orchestrator → EventManager → Callbacks</span></span></code></pre></div><h3 id="state-events" tabindex="-1">State Events <a class="header-anchor" href="#state-events" aria-label="Permalink to &quot;State Events&quot;">​</a></h3><p>These represent the internal status of the Agent. They indicate key lifecycle transitions such as:</p><ul><li>when the Agent is starting</li><li>when it&#39;s ready to execute</li><li>when it has completed its task</li></ul><p>These events are useful for <strong>observing</strong> the current state of each Agent and synchronizing other components in the system.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>To learn more about the different events, check out the <a href="./../../agents/#stateevents">Agent State Events</a> section.</p></div><h3 id="control-events" tabindex="-1">Control Events <a class="header-anchor" href="#control-events" aria-label="Permalink to &quot;Control Events&quot;">​</a></h3><p>These allow the Orchestrator (or other Agents) to <strong>drive</strong> the Agent&#39;s lifecycle. They are used to signal when the Agent is allowed to:</p><ul><li>start the setup phase</li><li>begin execution</li><li>stop gracefully</li></ul><p>Control events give you fine-grained control over each phase of execution, allowing custom orchestration strategies.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>To learn more about the different events, check out the <a href="./../../agents/#controlevents">Agent Control Events</a> section.</p></div><h2 id="validation-and-safety" tabindex="-1">Validation and Safety <a class="header-anchor" href="#validation-and-safety" aria-label="Permalink to &quot;Validation and Safety&quot;">​</a></h2><p>Each Agent comes with a built-in system to check if its configuration is correct before it starts running. This helps catch mistakes early and keeps your system safe and predictable.</p><h3 id="validation-policy" tabindex="-1">Validation Policy <a class="header-anchor" href="#validation-policy" aria-label="Permalink to &quot;Validation Policy&quot;">​</a></h3><p>The configuration of every Agent is checked using a <code>ValidationPolicy</code>. This lets you define how strict the validation should be for each setting.</p><p>You can assign different severity levels to each validation rule using <code>ValidationSeverity</code>:</p><ul><li><code>warning</code>: the Agent will still start, but you’ll get a log message letting you know something might need attention.</li><li><code>error</code>: the Agent won’t start, and an error will be logged — this is used for serious issues that could break execution.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>There’s also a special severity level: <code>critical</code>.<br> This one is used by some built-in Agents for essential checks that must <strong>never</strong> be ignored.</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>To learn more about the different validation policies, check out the <a href="./../../agents/#validation">Validation</a> section.</p></div><h2 id="grouping-and-control" tabindex="-1">Grouping and Control <a class="header-anchor" href="#grouping-and-control" aria-label="Permalink to &quot;Grouping and Control&quot;">​</a></h2><p>Agents can be grouped into <strong>logical collections</strong>, allowing the Orchestrator to manage them together. Groups can be used to filter Agents by function, priority, or lifecycle stage.</p><p>This enables bulk operations like restarting, stopping, or monitoring only a subset of Agents.</p>',53)]))}const k=t(h,[["render",g]]);export{v as __pageData,k as default};
