import{_ as t,c as o,a2 as a,o as n}from"./chunks/framework.BkvI1e0W.js";const s="/PyOrchestrateDocumentation/assets/reg_l.CziMgbBN.svg",r="/PyOrchestrateDocumentation/assets/reg_d.ZAYRvQC1.svg",i="/PyOrchestrateDocumentation/assets/multi_l.CFBLvMlZ.svg",c="/PyOrchestrateDocumentation/assets/multi_d.BZRGQ-hl.svg",l="/PyOrchestrateDocumentation/assets/execution_l.SXBiJ4LN.svg",h="/PyOrchestrateDocumentation/assets/execution_d.CTQ4QFGV.svg",b=JSON.parse('{"title":"How Orchestration Works","description":"","frontmatter":{"title":"How Orchestration Works","editLink":true},"headers":[],"relativePath":"learn/introduction/orchestrator/index.md","filePath":"learn/introduction/orchestrator/index.md","lastUpdated":1761471006000}'),d={name:"learn/introduction/orchestrator/index.md"};function g(u,e,p,m,y,f){return n(),o("div",null,e[0]||(e[0]=[a('<h1 id="how-orchestration-works" tabindex="-1">How Orchestration Works <a class="header-anchor" href="#how-orchestration-works" aria-label="Permalink to &quot;How Orchestration Works&quot;">​</a></h1><p>The <strong>Orchestrator</strong> is the component in charge of supervising and coordinating your <strong>Agents</strong>. It takes care of starting them, managing their lifecycle, and making sure everything runs smoothly — whether you&#39;re using threads, processes, or a mix of both.</p><h2 id="managing-agents" tabindex="-1">Managing Agents <a class="header-anchor" href="#managing-agents" aria-label="Permalink to &quot;Managing Agents&quot;">​</a></h2><h3 id="registering-agents" tabindex="-1">Registering Agents <a class="header-anchor" href="#registering-agents" aria-label="Permalink to &quot;Registering Agents&quot;">​</a></h3><p><img src="'+s+'" alt="alt text" class="light-only" loading="lazy"><img src="'+r+'" alt="alt text" class="dark-only" loading="lazy"></p><p>Before using the Orchestrator, you need to <strong>register the Agents</strong> you want it to manage.</p><p>This is done using the <code>register_agent()</code> method. You just provide:</p><ul><li>the Agent class,</li><li>a unique name,</li><li>and (optionally) a custom configuration or extra parameters.</li></ul><p>Once registered, the Orchestrator knows how to <strong>start</strong>, <strong>monitor</strong>, and <strong>stop</strong> the Agent.</p><div class="tip custom-block"><p class="custom-block-title">Behind the scenes</p><p>Each Agent is wrapped in an <code>AgentEntry</code> object that stores everything needed: the class, config, events, and more.</p></div><h3 id="running-multiple-agents-of-the-same-class" tabindex="-1">Running Multiple Agents of the Same Class <a class="header-anchor" href="#running-multiple-agents-of-the-same-class" aria-label="Permalink to &quot;Running Multiple Agents of the Same Class&quot;">​</a></h3><p>You can reuse the same <strong>Agent class</strong> to run <strong>multiple Agents</strong> that do slightly different things, all by changing their configuration.</p><p>For example, imagine you have a <code>FileWriterAgent</code> that writes data to a file. By passing a different file path to each one during registration, you can launch two Agents from the same class: one that writes to <code>log_a.txt</code> and another that writes to <code>log_b.txt</code>.</p><p><img src="'+i+'" alt="alt text" class="light-only" style="display:block;margin:0 auto;width:100%;" loading="lazy"><img src="'+c+'" alt="alt text" class="dark-only" style="display:block;margin:0 auto;width:100%;" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>For more details on how to register Agents, check out the <a href="./../../orchestrator/#registering-agents">Orchestrator Registering Agents</a>.</li><li>For more details on Agent&#39;s parameters and configuration, check out the <a href="./../../agents/#overview">Agent Overview</a>.</li></ul></div><h2 id="execution-lifecycle" tabindex="-1">Execution Lifecycle <a class="header-anchor" href="#execution-lifecycle" aria-label="Permalink to &quot;Execution Lifecycle&quot;">​</a></h2><h3 id="run-mode" tabindex="-1">Run Mode <a class="header-anchor" href="#run-mode" aria-label="Permalink to &quot;Run Mode&quot;">​</a></h3><p>The Orchestrator’s liveness is governed by an explicit lifecycle policy called <code>RunMode</code> and it’s required in the orchestrator configuration.</p><ul><li><code>STOP_ON_EMPTY</code> — batch-like: the orchestrator exits when all agents have completed and the queue is empty.</li><li><code>DAEMON</code> — service-like: the orchestrator stays alive until you explicitly shut it down, even if there are no running agents.</li></ul><h3 id="how-agent-execution-works" tabindex="-1">How Agent Execution Works <a class="header-anchor" href="#how-agent-execution-works" aria-label="Permalink to &quot;How Agent Execution Works&quot;">​</a></h3><p><img src="'+l+'" alt="alt text" class="light-only" loading="lazy"><img src="'+h+'" alt="alt text" class="dark-only" loading="lazy"></p><p>This section describes how execution proceeds; final liveness depends solely on the selected <code>RunMode</code>:</p><ol><li><p><strong>Check dependencies</strong></p><p>Before starting any Agent, the Orchestrator verifies that all declared dependencies exist and there are no circular references. It builds a valid startup order so each Agent launches only after its prerequisites.</p></li><li><p><strong>Start Agents</strong></p><p>The Orchestrator starts each Agent based on its dependency order using the Agent class&#39;s <code>start()</code> method. Depending on your configuration, this can run in a separate thread or process.</p></li><li><p><strong>Monitor running Agents</strong></p><p>The Orchestrator keeps track of all active Agents. When one finishes, it emits an <code>AGENT_TERMINATED</code> event and starts the next queued Agent, if any.</p></li><li><p><strong>Graceful termination vs. daemon behavior</strong></p><p>When all Agents have completed and the queue is empty, the Orchestrator emits an <code>ALL_AGENTS_TERMINATED</code> event. In <code>STOP_ON_EMPTY</code> it then terminates. In <code>DAEMON</code> it remains alive until you request shutdown.</p></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>You can subclass the <code>Orchestrator</code> class to change its behavior and plug in your own logic.</p></div><h3 id="parallel-execution-concurrency-limits" tabindex="-1">Parallel Execution &amp; Concurrency Limits <a class="header-anchor" href="#parallel-execution-concurrency-limits" aria-label="Permalink to &quot;Parallel Execution &amp; Concurrency Limits&quot;">​</a></h3><p>The Orchestrator supports <strong>concurrency limits</strong> to avoid overloading your system. You can define a <code>max_workers</code> value to cap how many Agents can run at the same time.</p><p>If the limit is reached, additional Agents are treated as <strong>queued Agents</strong>: they wait in line until a slot becomes available. As soon as one of the running Agents finishes, the next queued Agent is started automatically.</p><h3 id="a-simpler-way-to-wait" tabindex="-1">A Simpler Way to Wait <a class="header-anchor" href="#a-simpler-way-to-wait" aria-label="Permalink to &quot;A Simpler Way to Wait&quot;">​</a></h3><p>Sometimes you don’t need fine-grained lifecycle control or detailed event tracking.<br> If all you want is to <strong>start the Orchestrator and wait until it finishes</strong>, there’s a shortcut: <code>simple_join()</code>.</p><p>Think of it as a <strong>“just run it” button</strong>.</p><ul><li>In <code>STOP_ON_EMPTY</code> mode: the Orchestrator will exit once all Agents have completed.</li><li>In <code>DAEMON</code> mode: the Orchestrator will keep running until you explicitly shut it down.</li></ul><p>This is ideal for <strong>quick tests, prototypes, or simple automation tasks</strong>, where you don’t need advanced orchestration logic.</p><h2 id="events-and-monitoring" tabindex="-1">Events and Monitoring <a class="header-anchor" href="#events-and-monitoring" aria-label="Permalink to &quot;Events and Monitoring&quot;">​</a></h2><h3 id="reacting-to-events" tabindex="-1">Reacting to Events <a class="header-anchor" href="#reacting-to-events" aria-label="Permalink to &quot;Reacting to Events&quot;">​</a></h3><p>As Agents run, the Orchestrator emits events at key moments — when they start, stop, or when everything is done. These events flow through an <strong>Event Manager</strong>, and you can hook into them to trigger alerts, logs, dashboards, or custom reactions.</p><p>This is useful when you need to <strong>execute specific logic in response to Agent lifecycle events</strong>, such as notifying users or updating system status.</p><h3 id="cli" tabindex="-1">CLI <a class="header-anchor" href="#cli" aria-label="Permalink to &quot;CLI&quot;">​</a></h3><p>PyOrchestrate provides a runtime <strong>command interface</strong> (<code>CLI</code>) that communicates with the Orchestrator over a dedicated communication channel — a <code>UNIX socket</code> — much like how <strong>Docker</strong> talks to its daemon.</p><p>This channel lets external tools interact with the Orchestrator in real time:</p><ul><li><strong>Start or stop agents</strong></li><li><strong>Inspect running agents</strong></li><li><strong>Collect statistics and performance metrics</strong></li><li><strong>Query event history for auditing and debugging</strong></li></ul><p>The same command and data surface exposed by the CLI can also be used by a <strong>web-based interface</strong>, so dashboards and remote-control UIs can access the same functionality.</p><div class="tip custom-block"><p class="custom-block-title">Learn More</p><p>See the <a href="/PyOrchestrateDocumentation/cli/">CLI Documentation</a> for the full command reference, security notes, and examples of both CLI and web interfaces.</p></div><h2 id="customizing-the-behavior" tabindex="-1">Customizing the Behavior <a class="header-anchor" href="#customizing-the-behavior" aria-label="Permalink to &quot;Customizing the Behavior&quot;">​</a></h2><p>Every system has different needs:</p><ul><li>Some run like <strong>services</strong> that never stop.</li><li>Others behave more like <strong>batch jobs</strong>, doing their work and then exiting.</li><li>In some cases, you may want strict concurrency limits, detailed monitoring, or custom startup logic.</li></ul><p>To adapt to these scenarios, the Orchestrator provides a dedicated configuration object: <code>Orchestrator.Config</code>.<br> Through this object, you can <strong>fine-tune how the Orchestrator behaves</strong>, without changing your code.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For the complete technical details and available options, see:<br><a href="./../../orchestrator/#configuration">Orchestrator Configuration</a>.</p></div><h2 id="why-use-the-orchestrator" tabindex="-1">Why Use the Orchestrator? <a class="header-anchor" href="#why-use-the-orchestrator" aria-label="Permalink to &quot;Why Use the Orchestrator?&quot;">​</a></h2><p>The Orchestrator is not just a “manager of agents” — it’s the <strong>central brain of your system</strong>.<br> It ensures that your agents cooperate, remain observable, and can be controlled at runtime.</p><p>Here are some <strong>typical use cases</strong> where the Orchestrator shines:</p><ul><li><strong>Data Pipelines</strong>: start data collectors, processors, and writers in sequence or parallel, ensuring each stage runs only when ready.</li><li><strong>Monitoring Systems</strong>: keep multiple agents alive as background services, with events feeding into dashboards or alerts.</li><li><strong>Automation Workflows</strong>: coordinate different tasks (file watchers, API pollers, message processors) in a single, unified process.</li><li><strong>Resilient Applications</strong>: recover gracefully when an agent crashes, restart it, and keep the system stable without manual intervention.</li></ul><p>By abstracting away threads, processes, and low-level synchronization, the Orchestrator lets you focus on <strong>what your agents do</strong>, not on <strong>how they’re coordinated</strong>.</p>',52)]))}const w=t(d,[["render",g]]);export{b as __pageData,w as default};
