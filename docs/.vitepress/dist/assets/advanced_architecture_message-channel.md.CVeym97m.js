import{_ as c,c as h,a2 as s,b as i,w as a,a3 as o,B as d,o as t,G as r,a as l}from"./chunks/framework.BkvI1e0W.js";const f=JSON.parse('{"title":"MessageChannel","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/architecture/message-channel.md","filePath":"advanced/architecture/message-channel.md","lastUpdated":1761471006000}'),p={name:"advanced/architecture/message-channel.md"};function m(g,e,u,k,b,C){const n=d("Mermaid");return t(),h("div",null,[e[2]||(e[2]=s('<h1 id="messagechannel" tabindex="-1">MessageChannel <a class="header-anchor" href="#messagechannel" aria-label="Permalink to &quot;MessageChannel&quot;">​</a></h1><p>The <code>MessageChannel</code> class serves as the core communication infrastructure in PyOrchestrate, providing a unified interface for message passing between different system components.</p><h2 id="architecture-overview" tabindex="-1">Architecture Overview <a class="header-anchor" href="#architecture-overview" aria-label="Permalink to &quot;Architecture Overview&quot;">​</a></h2><h3 id="core-design-principles" tabindex="-1">Core Design Principles <a class="header-anchor" href="#core-design-principles" aria-label="Permalink to &quot;Core Design Principles&quot;">​</a></h3><p>The <code>MessageChannel</code> class is the internal backbone for communication between the main components of PyOrchestrate. It provides two distinct communication mechanisms:</p><ol><li><strong>Queue-based MessageChannel</strong>: Used for communication between the orchestrator and its agents.</li><li><strong>Socket-based MessageChannel</strong>: Used for communication between the orchestrator and external CLI tools. This uses UNIX domain sockets and is also bidirectional, but designed for integration with external processes.</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For user-facing or custom communication needs, PyOrchestrate provides a flexible plugin system <a href="./../../learn/agents/plugins/communication-plugins.html">Communication Plugins</a> that users can extend and configure as needed.</p></div><h4 id="_1-queue-based-messagechannel" tabindex="-1">1. Queue-based MessageChannel <a class="header-anchor" href="#_1-queue-based-messagechannel" aria-label="Permalink to &quot;1. Queue-based MessageChannel&quot;">​</a></h4><p>Communication between the orchestrator and agents is handled by a shared <code>MessageChannel</code> of type <code>process</code> or <code>thread</code>. This channel is always local and supports bidirectional messaging.</p>',9)),(t(),i(o,null,{default:a(()=>[r(n,{id:"mermaid-38",class:"mermaid my-class",graph:"flowchart%20LR%0A%20%20%20%20O%5BOrchestrator%5D%0A%20%20%20%20A1%5BAgent%201%5D%0A%20%20%20%20A2%5BAgent%202%5D%0A%20%20%20%20A3%5BAgent%20N%5D%0A%20%20%20%20O%20%3C--%3E%20A1%0A%20%20%20%20O%20%3C--%3E%20A2%0A%20%20%20%20O%20%3C--%3E%20A3%0A"})]),fallback:a(()=>e[0]||(e[0]=[l(" Loading... ")])),_:1})),e[3]||(e[3]=s('<p>Only messages of type <code>STATUS</code> are sent from agents to the orchestrator. The orchestrator processes these messages and emits corresponding events through the <code>EventManager</code>.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Currently, messages from the orchestrator to agents via the MessageChannel are not handled. Only agent-to-orchestrator communication is supported through this channel.</p></div><p>The main events handled are:</p><ul><li><code>AGENT_TERMINATED</code>: The agent has closed.</li><li><code>AGENT_STARTED</code>: The agent has started.</li><li><code>AGENT_READY</code>: The agent is ready.</li><li><code>AGENT_ERROR</code>: The agent reported an error (payload starts with <code>ERROR:</code>).</li></ul><h4 id="_2-socket-based-messagechannel" tabindex="-1">2. Socket-based MessageChannel <a class="header-anchor" href="#_2-socket-based-messagechannel" aria-label="Permalink to &quot;2. Socket-based MessageChannel&quot;">​</a></h4><p>Communication between the orchestrator and external CLI tools is handled by a separate <code>MessageChannel</code> of type <code>unix_socket</code>. This allows external processes to send commands and receive responses from the orchestrator.</p>',6)),(t(),i(o,null,{default:a(()=>[r(n,{id:"mermaid-78",class:"mermaid my-class",graph:"flowchart%20LR%0A%20%20%20%20O%5BOrchestrator%5D%0A%20%20%20%20CLI%5BExternal%20CLI%20Tool%5D%0A%20%20%20%20O%20%3C--%3E%20CLI%0A"})]),fallback:a(()=>e[1]||(e[1]=[l(" Loading... ")])),_:1})),e[4]||(e[4]=s(`<p>When a message is received from the CLI via the socket-based MessageChannel, the orchestrator parses the payload as JSON, extracts the command and arguments, and delegates execution to a <code>CommandHandler</code>. The response (or error) is then sent back to the CLI through the same channel.</p><h3 id="message-format" tabindex="-1">Message Format <a class="header-anchor" href="#message-format" aria-label="Permalink to &quot;Message Format&quot;">​</a></h3><p>All communication uses the standardized <code>ServiceMessage</code> dataclass:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@dataclass</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServiceMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sender: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Literal[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;COMMAND&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;STATUS&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    payload: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timestamp: datetime</span></span></code></pre></div>`,4))])}const y=c(p,[["render",m]]);export{f as __pageData,y as default};
