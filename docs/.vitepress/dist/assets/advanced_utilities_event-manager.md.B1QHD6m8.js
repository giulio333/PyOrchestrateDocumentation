import{_ as i,c as r,a2 as t,b as o,w as a,a3 as l,B as h,o as s,G as d,a as c}from"./chunks/framework.BkvI1e0W.js";const b=JSON.parse('{"title":"Event Manager","description":"","frontmatter":{"title":"Event Manager","editLink":true},"headers":[],"relativePath":"advanced/utilities/event-manager.md","filePath":"advanced/utilities/event-manager.md","lastUpdated":1761471006000}'),p={name:"advanced/utilities/event-manager.md"};function g(k,e,u,E,m,v){const n=h("Mermaid");return s(),r("div",null,[e[1]||(e[1]=t(`<h1 id="event-manager" tabindex="-1">Event Manager <a class="header-anchor" href="#event-manager" aria-label="Permalink to &quot;Event Manager&quot;">​</a></h1><p>The <strong>Event Manager</strong> in PyOrchestrate is a core component of the Orchestrator. It provides a robust, asynchronous, and type-safe mechanism for handling system-wide events related to agent lifecycle and orchestration.</p><h2 id="how-it-works" tabindex="-1">How It Works <a class="header-anchor" href="#how-it-works" aria-label="Permalink to &quot;How It Works&quot;">​</a></h2><ul><li>The Orchestrator owns a single EventManager instance.</li><li>Agents never interact directly with the EventManager. Instead, they send messages to the Orchestrator via a MessageChannel.</li><li>The Orchestrator receives these messages and emits the corresponding <strong>OrchestratorEvent</strong> through its EventManager.</li><li>Users can register callbacks for these events using <code>orchestrator.register_event()</code>.</li></ul><h2 id="event-types" tabindex="-1">Event Types <a class="header-anchor" href="#event-types" aria-label="Permalink to &quot;Event Types&quot;">​</a></h2><p>All events managed by the Orchestrator&#39;s EventManager are of type <strong>OrchestratorEvent</strong>. These include:</p><table tabindex="0"><thead><tr><th>Event Name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td><code>AGENT_STARTED</code></td><td><code>event_date</code>, <code>event_time</code>, <code>agent_name</code></td><td>Emitted when an agent starts.</td></tr><tr><td><code>AGENT_TERMINATED</code></td><td><code>event_date</code>, <code>event_time</code>, <code>agent_name</code></td><td>Emitted when an agent terminates.</td></tr><tr><td><code>AGENT_READY</code></td><td><code>event_date</code>, <code>event_time</code>, <code>agent_name</code></td><td>Emitted when an agent signals readiness.</td></tr><tr><td><code>AGENT_ERROR</code></td><td><code>event_date</code>, <code>event_time</code>, <code>agent_name</code>, <code>error_message</code></td><td>Emitted when an agent reports an error.</td></tr><tr><td><code>AGENT_HEARTBEAT</code></td><td>Take no arguments</td><td>Emitted when an agent sends a heartbeat.</td></tr></tbody></table><h2 id="registering-event-callbacks" tabindex="-1">Registering Event Callbacks <a class="header-anchor" href="#registering-event-callbacks" aria-label="Permalink to &quot;Registering Event Callbacks&quot;">​</a></h2><p>To react to orchestration events, register your callback using the Orchestrator:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PyOrchestrate.core.utilities.event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OrchestratorEvent</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> on_agent_started</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(agent_name, event_time, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwargs):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Agent </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">agent_name</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> started at </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event_time</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">orchestrator.register_event(OrchestratorEvent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AGENT_STARTED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, on_agent_started)</span></span></code></pre></div><h2 id="agent-events-through-orchestrator" tabindex="-1">Agent Events Through Orchestrator <a class="header-anchor" href="#agent-events-through-orchestrator" aria-label="Permalink to &quot;Agent Events Through Orchestrator&quot;">​</a></h2><p>When an agent changes state (start, ready, terminate, error), it sends a message to the Orchestrator via the MessageChannel. The Orchestrator then emits the corresponding OrchestratorEvent, triggering all registered callbacks for that event.</p><p><strong>Event flow:</strong></p>`,13)),(s(),o(l,null,{default:a(()=>[d(n,{id:"mermaid-125",class:"mermaid my-class",graph:"flowchart%20LR%0A%20%20%20%20Agent%20--%20sends%20event%20--%3E%20MessageChannel%0A%20%20%20%20MessageChannel%20--%20forwards%20--%3E%20Orchestrator%0A%20%20%20%20Orchestrator%20--%20emits%20event%20--%3E%20EventManager%0A%20%20%20%20EventManager%20--%20triggers%20--%3E%20Callbacks%0A"})]),fallback:a(()=>e[0]||(e[0]=[c(" Loading... ")])),_:1})),e[2]||(e[2]=t('<h2 id="technical-details" tabindex="-1">Technical Details <a class="header-anchor" href="#technical-details" aria-label="Permalink to &quot;Technical Details&quot;">​</a></h2><h3 id="parameter-filtering" tabindex="-1">Parameter Filtering <a class="header-anchor" href="#parameter-filtering" aria-label="Permalink to &quot;Parameter Filtering&quot;">​</a></h3><p>When emitting an event, the EventManager automatically inspects the signature of each registered callback and only passes the parameters that the callback accepts. This allows you to write concise and type-safe handlers without worrying about extra arguments.</p><ul><li>If your callback only needs <code>agent_name</code>, it will only receive that.</li><li>If you want full context, you can accept <code>**kwargs</code> to get all available data.</li></ul><h3 id="thread-pool-asynchronous-execution" tabindex="-1">Thread Pool &amp; Asynchronous Execution <a class="header-anchor" href="#thread-pool-asynchronous-execution" aria-label="Permalink to &quot;Thread Pool &amp; Asynchronous Execution&quot;">​</a></h3><p>All event callbacks are executed asynchronously using a thread pool. This ensures that:</p><ul><li>Event emission never blocks the main orchestration loop.</li><li>Slow or blocking callbacks do not delay other event handlers.</li><li>The number of concurrent callback executions is limited by the thread pool size (default: 10).</li></ul><h3 id="error-isolation" tabindex="-1">Error Isolation <a class="header-anchor" href="#error-isolation" aria-label="Permalink to &quot;Error Isolation&quot;">​</a></h3><p>If a callback raises an exception, the EventManager catches and logs the error, but continues executing all other callbacks for the same event. This guarantees that a bug in one handler does not affect the rest of the system.</p><h3 id="shutdown" tabindex="-1">Shutdown <a class="header-anchor" href="#shutdown" aria-label="Permalink to &quot;Shutdown&quot;">​</a></h3><p>When the Orchestrator (or your application) is shutting down, the EventManager should be shut down gracefully to ensure all pending callbacks are completed. This is handled automatically, but you can also call:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">orchestrator.event_manager.shutdown()</span></span></code></pre></div><p>This will wait for all running callbacks to finish and release resources.</p>',13))])}const f=i(p,[["render",g]]);export{b as __pageData,f as default};
